<h3 id="storm-is-an-application-container">Storm is an Application Container</h3>

<p>Storm provides an application container environment, a la Apache Tomcat, which creates a potential for classpath conflicts between Storm and your application.  The most common way of using Storm involves submitting an “uber JAR” containing your application code with all of its dependencies bundled in, and then Storm distributes this JAR to Worker nodes.  Then Storm runs your application within a Storm process called a <code class="language-plaintext highlighter-rouge">Worker</code> – thus the JVM’s classpath contains the dependencies of your JAR as well as whatever dependencies the Worker itself has.  So careful handling of classpaths and dependencies is critical for the correct functioning of Storm.</p>

<h3 id="adding-extra-dependencies-to-classpath">Adding Extra Dependencies to Classpath</h3>

<p>You no longer <em>need</em> to bundle your dependencies into your topology and create an uber JAR, there are now facilities for separately handling your topology’s dependencies.  Furthermore, there are facilities for adding external dependencies into the Storm daemons.</p>

<p>The <code class="language-plaintext highlighter-rouge">storm.py</code> launcher script allows you to include dependencies into the launched program’s classpath via a few different mechanisms:</p>

<ol>
  <li>The <code class="language-plaintext highlighter-rouge">--jar</code> and <code class="language-plaintext highlighter-rouge">--artifacts</code> options for the <code class="language-plaintext highlighter-rouge">storm jar</code> command: allow the inclusion of non-bundled dependencies with your topology; i.e., allowing specification of JARs that were not bundled into the topology uber-jar.  This is required when using the <code class="language-plaintext highlighter-rouge">storm sql</code> command, which constructs a topology automatically without needing you to write code and build a topology JAR.</li>
  <li>The <code class="language-plaintext highlighter-rouge">${STORM_DIR}/extlib/</code> and <code class="language-plaintext highlighter-rouge">${STORM_DIR}/extlib-daemon/</code> directories can have dependencies added to them for the inclusion of plugins &amp; 3rd-party libraries into the Storm daemons (e.g., Nimbus, UI, Supervisor, etc. – use <code class="language-plaintext highlighter-rouge">extlib-daemon/</code>) and other commands launched via the <code class="language-plaintext highlighter-rouge">storm.py</code> script, e.g., <code class="language-plaintext highlighter-rouge">storm sql</code> and <code class="language-plaintext highlighter-rouge">storm jar</code> (use <code class="language-plaintext highlighter-rouge">extlib</code>). Notably, this means that the Storm Worker process does not include the <code class="language-plaintext highlighter-rouge">extlib-daemon/</code> directory into its classpath.</li>
  <li>The <code class="language-plaintext highlighter-rouge">STORM_EXT_CLASSPATH</code> and <code class="language-plaintext highlighter-rouge">STORM_EXT_CLASSPATH_DAEMON</code> environment variables provide a similar functionality as those directories, but allows the user to place their external dependencies in alternative locations.
    <ul>
      <li>There is a wrinkle here: because the Supervisor daemon launches the Worker process, if you want <code class="language-plaintext highlighter-rouge">STORM_EXT_CLASSPATH</code> to impact your Workers, you will need to specify the <code class="language-plaintext highlighter-rouge">STORM_EXT_CLASSPATH</code> for the Supervisor daemon.  That will allow the Supervisor to consult this environment variable as it constructs the classpath of the Worker processes.</li>
    </ul>
  </li>
</ol>

<h4 id="which-facility-to-choose">Which Facility to Choose?</h4>

<p>You might have noticed the overlap between the first mechanism and the others. If you consider the <code class="language-plaintext highlighter-rouge">--jar</code> / <code class="language-plaintext highlighter-rouge">--artifacts</code> option versus the <code class="language-plaintext highlighter-rouge">extlib/</code> / <code class="language-plaintext highlighter-rouge">STORM_EXT_CLASSPATH</code> it is not obvious which one you should choose for using dependencies with your Worker processes. i.e., both mechanisms allow including JARs to be used for running your Worker processes. Here is my understanding of the difference: <code class="language-plaintext highlighter-rouge">--jar</code> / <code class="language-plaintext highlighter-rouge">--artifacts</code> will result in the dependencies being used for running the <code class="language-plaintext highlighter-rouge">storm jar/sql</code> command, <em>and</em> the dependencies will be uploaded and available in the classpath of the topology’s <code class="language-plaintext highlighter-rouge">Worker</code> processes. Whereas the use of <code class="language-plaintext highlighter-rouge">extlib/</code> / <code class="language-plaintext highlighter-rouge">STORM_EXT_CLASSPATH</code> requires you to have distributed your JAR dependencies out to all Worker nodes.  Another difference is that <code class="language-plaintext highlighter-rouge">extlib/</code> / <code class="language-plaintext highlighter-rouge">STORM_EXT_CLASSPATH</code> would impact all topologies, whereas <code class="language-plaintext highlighter-rouge">--jar</code> / <code class="language-plaintext highlighter-rouge">--artifacts</code> is a topology-specific option.</p>

<h3 id="abbreviation-of-classpaths-and-process-commands">Abbreviation of Classpaths and Process Commands</h3>

<p>When the <code class="language-plaintext highlighter-rouge">storm.py</code> script launches a <code class="language-plaintext highlighter-rouge">java</code> command, it first constructs the classpath from the optional settings mentioned above, as well as including some default locations such as the <code class="language-plaintext highlighter-rouge">${STORM_DIR}/</code>, <code class="language-plaintext highlighter-rouge">${STORM_DIR}/lib/</code>, <code class="language-plaintext highlighter-rouge">${STORM_DIR}/extlib/</code> and <code class="language-plaintext highlighter-rouge">${STORM_DIR}/extlib-daemon/</code> directories.  In past releases, Storm would enumerate all JARs in those directories and then explicitly add all of those JARs into the <code class="language-plaintext highlighter-rouge">-cp</code> / <code class="language-plaintext highlighter-rouge">--classpath</code> argument to the launched <code class="language-plaintext highlighter-rouge">java</code> commands.  As such, the classpath would get so long that the <code class="language-plaintext highlighter-rouge">java</code> commands could breach the Linux Kernel process table limit of 4096 bytes for recording commands.  That led to truncated commands in <code class="language-plaintext highlighter-rouge">ps</code> output, making it hard to operate Storm clusters because you could not easily differentiate the processes nor easily see from <code class="language-plaintext highlighter-rouge">ps</code> which port a worker is listening to.</p>

<p>After Storm dropped support for Java 5, this classpath expansion was no longer necessary, because Java 6 supports classpath wildcards. Classpath wildcards allow you to specify a directory ending with a <code class="language-plaintext highlighter-rouge">*</code> element, such as <code class="language-plaintext highlighter-rouge">foo/bar/*</code>, and the JVM will automatically expand the classpath to include all <code class="language-plaintext highlighter-rouge">.jar</code> files in the wildcard directory.  As of <a href="https://issues.apache.org/jira/browse/STORM-2191">STORM-2191</a> Storm just uses classpath wildcards instead of explicitly listing all JARs, thereby shortening all of the commands and making operating Storm clusters a bit easier.</p>
