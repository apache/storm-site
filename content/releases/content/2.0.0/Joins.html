<p>Storm core supports joining multiple data streams into one with the help of <code class="language-plaintext highlighter-rouge">JoinBolt</code>.
<code class="language-plaintext highlighter-rouge">JoinBolt</code> is a Windowed bolt, i.e. it waits for the configured window duration to match up the
tuples among the streams being joined. This helps align the streams within a Window boundary.</p>

<p>Each of <code class="language-plaintext highlighter-rouge">JoinBolt</code>’s incoming data streams must be Fields Grouped on a single field. A stream 
should only be joined with the other streams using the field on which it has been FieldsGrouped.<br />
Knowing this will help understand the join syntax described below.</p>

<h2 id="performing-joins">Performing Joins</h2>
<p>Consider the following SQL join involving 4 tables:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">select</span>  <span class="n">userId</span><span class="p">,</span> <span class="n">key4</span><span class="p">,</span> <span class="n">key2</span><span class="p">,</span> <span class="n">key3</span>
<span class="k">from</span>        <span class="n">table1</span>
<span class="k">inner</span> <span class="k">join</span>  <span class="n">table2</span>  <span class="k">on</span> <span class="n">table2</span><span class="p">.</span><span class="n">userId</span> <span class="o">=</span>  <span class="n">table1</span><span class="p">.</span><span class="n">key1</span>
<span class="k">inner</span> <span class="k">join</span>  <span class="n">table3</span>  <span class="k">on</span> <span class="n">table3</span><span class="p">.</span><span class="n">key3</span>   <span class="o">=</span>  <span class="n">table2</span><span class="p">.</span><span class="n">userId</span>
<span class="k">left</span> <span class="k">join</span>   <span class="n">table4</span>  <span class="k">on</span> <span class="n">table4</span><span class="p">.</span><span class="n">key4</span>   <span class="o">=</span>  <span class="n">table3</span><span class="p">.</span><span class="n">key3</span>
</code></pre></div></div>

<p>Similar joins could be expressed on tuples generated by 4 spouts using <code class="language-plaintext highlighter-rouge">JoinBolt</code>:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">JoinBolt</span> <span class="n">jbolt</span> <span class="o">=</span>  <span class="k">new</span> <span class="nc">JoinBolt</span><span class="o">(</span><span class="s">"spout1"</span><span class="o">,</span> <span class="s">"key1"</span><span class="o">)</span>                   <span class="c1">// from        spout1  </span>
                    <span class="o">.</span><span class="na">join</span>     <span class="o">(</span><span class="s">"spout2"</span><span class="o">,</span> <span class="s">"userId"</span><span class="o">,</span>  <span class="s">"spout1"</span><span class="o">)</span>      <span class="c1">// inner join  spout2  on spout2.userId = spout1.key1</span>
                    <span class="o">.</span><span class="na">join</span>     <span class="o">(</span><span class="s">"spout3"</span><span class="o">,</span> <span class="s">"key3"</span><span class="o">,</span>    <span class="s">"spout2"</span><span class="o">)</span>      <span class="c1">// inner join  spout3  on spout3.key3   = spout2.userId   </span>
                    <span class="o">.</span><span class="na">leftJoin</span> <span class="o">(</span><span class="s">"spout4"</span><span class="o">,</span> <span class="s">"key4"</span><span class="o">,</span>    <span class="s">"spout3"</span><span class="o">)</span>      <span class="c1">// left join   spout4  on spout4.key4   = spout3.key3</span>
                    <span class="o">.</span><span class="na">select</span>  <span class="o">(</span><span class="s">"userId, key4, key2, spout3:key3"</span><span class="o">)</span>   <span class="c1">// chose output fields</span>
                    <span class="o">.</span><span class="na">withTumblingWindow</span><span class="o">(</span> <span class="k">new</span> <span class="nc">Duration</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="nc">TimeUnit</span><span class="o">.</span><span class="na">MINUTES</span><span class="o">)</span> <span class="o">)</span> <span class="o">;</span>

<span class="n">topoBuilder</span><span class="o">.</span><span class="na">setBolt</span><span class="o">(</span><span class="s">"joiner"</span><span class="o">,</span> <span class="n">jbolt</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>
            <span class="o">.</span><span class="na">fieldsGrouping</span><span class="o">(</span><span class="s">"spout1"</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Fields</span><span class="o">(</span><span class="s">"key1"</span><span class="o">)</span> <span class="o">)</span>
            <span class="o">.</span><span class="na">fieldsGrouping</span><span class="o">(</span><span class="s">"spout2"</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Fields</span><span class="o">(</span><span class="s">"userId"</span><span class="o">)</span> <span class="o">)</span>
            <span class="o">.</span><span class="na">fieldsGrouping</span><span class="o">(</span><span class="s">"spout3"</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Fields</span><span class="o">(</span><span class="s">"key3"</span><span class="o">)</span> <span class="o">)</span>
            <span class="o">.</span><span class="na">fieldsGrouping</span><span class="o">(</span><span class="s">"spout4"</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Fields</span><span class="o">(</span><span class="s">"key4"</span><span class="o">)</span> <span class="o">);</span>
</code></pre></div></div>

<p>The bolt constructor takes two arguments. The 1st argument introduces the data from <code class="language-plaintext highlighter-rouge">spout1</code>
to be the first stream and specifies that it will always use field <code class="language-plaintext highlighter-rouge">key1</code> when joining this with the others streams.
The name of the component specified must refer to the spout or bolt that is directly connected to the Join bolt. 
Here data received from <code class="language-plaintext highlighter-rouge">spout1</code> must be fields grouped on <code class="language-plaintext highlighter-rouge">key1</code>. Similarly, each of the <code class="language-plaintext highlighter-rouge">leftJoin()</code> and <code class="language-plaintext highlighter-rouge">join()</code> method
calls introduce a new stream along with the field to use for the join. As seen in above example, the same FieldsGrouping
requirement applies to these streams as well. The 3rd argument to the join methods refers to another stream with which
to join.</p>

<p>The <code class="language-plaintext highlighter-rouge">select()</code> method is used to specify the output fields. The argument to <code class="language-plaintext highlighter-rouge">select</code> is a comma separated list of fields.
Individual field names can be prefixed with a stream name to disambiguate between the same field name occurring in
multiple streams as follows:  <code class="language-plaintext highlighter-rouge">.select("spout3:key3, spout4:key3")</code>. Nested tuple types are supported if the
nesting has been done using <code class="language-plaintext highlighter-rouge">Map</code>s. For example  <code class="language-plaintext highlighter-rouge">outer.inner.innermost</code> refers to a field that is nested three levels
deep where <code class="language-plaintext highlighter-rouge">outer</code> and <code class="language-plaintext highlighter-rouge">inner</code> are of type <code class="language-plaintext highlighter-rouge">Map</code>.</p>

<p>Stream name prefix is not allowed for the fields in any of the join() arguments, but nested fields are supported.</p>

<p>The call to <code class="language-plaintext highlighter-rouge">withTumblingWindow()</code> above, configures the join window to be a 10 minute tumbling window. Since <code class="language-plaintext highlighter-rouge">JoinBolt</code> 
is a Windowed Bolt, we can also use the <code class="language-plaintext highlighter-rouge">withWindow</code> method to configure it as a sliding window (see tips section below).</p>

<h2 id="stream-names-and-join-order">Stream names and Join order</h2>
<ul>
  <li>Stream names must be introduced (in constructor or as 1st arg to various join methods) before being referred
to (in the 3rd argument of the join methods). Forward referencing of stream names, as shown below, is not allowed:</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">new</span> <span class="nc">JoinBolt</span><span class="o">(</span> <span class="s">"spout1"</span><span class="o">,</span> <span class="s">"key1"</span><span class="o">)</span>                 
  <span class="o">.</span><span class="na">join</span>     <span class="o">(</span> <span class="s">"spout2"</span><span class="o">,</span> <span class="s">"userId"</span><span class="o">,</span>  <span class="s">"spout3"</span><span class="o">)</span> <span class="c1">//not allowed. spout3 not yet introduced</span>
  <span class="o">.</span><span class="na">join</span>     <span class="o">(</span> <span class="s">"spout3"</span><span class="o">,</span> <span class="s">"key3"</span><span class="o">,</span>    <span class="s">"spout1"</span><span class="o">)</span>
</code></pre></div></div>
<ul>
  <li>Internally, the joins will be performed in the order expressed by the user.</li>
</ul>

<h2 id="joining-based-on-stream-names">Joining based on Stream names</h2>

<p>For simplicity, Storm topologies often use the <code class="language-plaintext highlighter-rouge">default</code> stream. Topologies can also use named streams 
instead of <code class="language-plaintext highlighter-rouge">default</code> streams.  To support such topologies, <code class="language-plaintext highlighter-rouge">JoinBolt</code> can be configured to use stream
names,  instead of source component (spout/bolt) names, via the constructor’s first argument:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">new</span> <span class="nc">JoinBolt</span><span class="o">(</span><span class="nc">JoinBolt</span><span class="o">.</span><span class="na">Selector</span><span class="o">.</span><span class="na">STREAM</span><span class="o">,</span>  <span class="s">"stream1"</span><span class="o">,</span> <span class="s">"key1"</span><span class="o">)</span>
                                  <span class="o">.</span><span class="na">join</span><span class="o">(</span><span class="s">"stream2"</span><span class="o">,</span> <span class="s">"key2"</span><span class="o">)</span>
    <span class="o">...</span>
</code></pre></div></div>
<p>The first argument <code class="language-plaintext highlighter-rouge">JoinBolt.Selector.STREAM</code> informs the bolt that <code class="language-plaintext highlighter-rouge">stream1/2/3/4</code> refer to named streams
(as opposed to names of upstream spouts/bolts).</p>

<p>The below example joins two named streams from four spouts:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">new</span> <span class="nc">JoinBolt</span><span class="o">(</span><span class="nc">JoinBolt</span><span class="o">.</span><span class="na">Selector</span><span class="o">.</span><span class="na">STREAM</span><span class="o">,</span>  <span class="s">"stream1"</span><span class="o">,</span> <span class="s">"key1"</span><span class="o">)</span> 
                             <span class="o">.</span><span class="na">join</span>     <span class="o">(</span><span class="s">"stream2"</span><span class="o">,</span> <span class="s">"userId"</span><span class="o">,</span>  <span class="s">"stream1"</span> <span class="o">)</span>
                             <span class="o">.</span><span class="na">select</span> <span class="o">(</span><span class="s">"userId, key1, key2"</span><span class="o">)</span>
                             <span class="o">.</span><span class="na">withTumblingWindow</span><span class="o">(</span> <span class="k">new</span> <span class="nc">Duration</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="nc">TimeUnit</span><span class="o">.</span><span class="na">MINUTES</span><span class="o">)</span> <span class="o">)</span> <span class="o">;</span>
                             
<span class="n">topoBuilder</span><span class="o">.</span><span class="na">setBolt</span><span class="o">(</span><span class="s">"joiner"</span><span class="o">,</span> <span class="n">jbolt</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>
            <span class="o">.</span><span class="na">fieldsGrouping</span><span class="o">(</span><span class="s">"bolt1"</span><span class="o">,</span> <span class="s">"stream1"</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Fields</span><span class="o">(</span><span class="s">"key1"</span><span class="o">)</span> <span class="o">)</span>
            <span class="o">.</span><span class="na">fieldsGrouping</span><span class="o">(</span><span class="s">"bolt2"</span><span class="o">,</span> <span class="s">"stream1"</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Fields</span><span class="o">(</span><span class="s">"key1"</span><span class="o">)</span> <span class="o">)</span>
            <span class="o">.</span><span class="na">fieldsGrouping</span><span class="o">(</span><span class="s">"bolt3"</span><span class="o">,</span> <span class="s">"stream2"</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Fields</span><span class="o">(</span><span class="s">"userId"</span><span class="o">)</span> <span class="o">)</span>
            <span class="o">.</span><span class="na">fieldsGrouping</span><span class="o">(</span><span class="s">"bolt4"</span><span class="o">,</span> <span class="s">"stream1"</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Fields</span><span class="o">(</span><span class="s">"key1"</span><span class="o">)</span> <span class="o">);</span>
</code></pre></div></div>

<p>In the above example, it is possible that <code class="language-plaintext highlighter-rouge">bolt1</code>, for example, is emitting other streams also. But the join bolt 
is only subscribing to <code class="language-plaintext highlighter-rouge">stream1</code> &amp; <code class="language-plaintext highlighter-rouge">stream2</code> from the different bolts. <code class="language-plaintext highlighter-rouge">stream1</code> from <code class="language-plaintext highlighter-rouge">bolt1</code>, <code class="language-plaintext highlighter-rouge">bolt2</code> and <code class="language-plaintext highlighter-rouge">bolt4</code> 
is treated as a single stream and joined against <code class="language-plaintext highlighter-rouge">stream2</code> from <code class="language-plaintext highlighter-rouge">bolt3</code>.</p>

<h2 id="limitations">Limitations:</h2>
<ol>
  <li>
    <p>Currently only INNER and LEFT joins are supported.</p>
  </li>
  <li>
    <p>Unlike SQL, which allows joining the same table on different keys to different tables, here the same one field must be used
on a stream. Fields Grouping ensures the right tuples are routed to the right instances of a Join Bolt. Consequently the 
FieldsGrouping field must be same as the join field, for correct results. To perform joins on multiple fields, the fields 
can be combined into one field and then sent to the Join bolt.</p>
  </li>
</ol>

<h2 id="tips">Tips:</h2>

<ol>
  <li>
    <p>Joins can be CPU and memory intensive. The larger the data accumulated in the current window (proportional to window
length), the longer it takes to do the join. Having a short sliding interval (few seconds for example) triggers frequent
 joins. Consequently performance can suffer if using large window lengths or small sliding intervals or both.</p>
  </li>
  <li>
    <p>Duplication of joined records across windows is possible when using Sliding Windows. This is because the tuples continue to exist
across multiple windows when using Sliding Windows.</p>
  </li>
  <li>
    <p>If message timeouts are enabled, ensure the timeout setting (topology.message.timeout.secs) is large enough to comfortably
accommodate the window size, plus the additional processing by other spouts and bolts.</p>
  </li>
  <li>
    <p>Joining a window of two streams with M and N elements each, <em>in the worst case</em>, can produce MxN elements with every output tuple
anchored to one tuple from each input stream. This can mean a lot of output tuples from JoinBolt and even more ACKs for downstream bolts
to emit. This can place a substantial pressure on the messaging system and dramatically slowdown the topology if not careful.
To manage the load on the messaging subsystem, it is advisable to:</p>
    <ul>
      <li>Increase the worker’s heap (topology.worker.max.heap.size.mb).</li>
      <li><strong>If</strong> ACKing is not necessary for your topology, disable ACKers (topology.acker.executors=0).</li>
      <li>Disable event logger (topology.eventlogger.executors=0).</li>
      <li>Turn of topology debugging (topology.debug=false).</li>
      <li>Set topology.max.spout.pending to a value large enough to accommodate an estimated full window worth of tuples plus some more for headroom.
This helps mitigate the possibility of spouts emitting excessive tuples when messaging subsystem is experiencing excessive load. This situation
can occur when its value is set to null.</li>
      <li>Lastly, keep the window size to the minimum value necessary for solving the problem at hand.</li>
    </ul>
  </li>
</ol>
